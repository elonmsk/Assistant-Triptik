import { NextResponse } from "next/server"
import { createClient } from "@supabase/supabase-js"

const supabase = createClient(
  "https://amikskoyjbqdvvohgssv.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFtaWtza295amJxZHZ2b2hnc3N2Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NTkxNDMyMywiZXhwIjoyMDYxNDkwMzIzfQ.U61LP1XdvyvzV-VlNEPslMptZ_pAAyum4g5qONm2vlI"
)

// Configuration pour votre API LLM sur Render
// TODO: Remplacer par votre vraie URL API Render
const EXTERNAL_API_URL = process.env.EXTERNAL_API_URL || "https://assistant-nouveaux-arrivants-france.onrender.com";
const RENDER_API_KEY = process.env.RENDER_API_KEY || "";

interface ChatRequest {
  message: string
  conversationId?: string
  userNumero: string
  userType: 'accompagne' | 'accompagnant'
  theme?: string
}

export async function POST(req: Request) {
  try {
    const { message, conversationId, userNumero, userType, theme }: ChatRequest = await req.json()

    if (!message || !userNumero || !userType) {
      return NextResponse.json(
        { error: "Message, num√©ro utilisateur et type d'utilisateur requis" },
        { status: 400 }
      )
    }

    // 1. R√©cup√©rer ou cr√©er une conversation
    let currentConversationId = conversationId
    
    if (!currentConversationId) {
      // Cr√©er une nouvelle conversation
      const { data: newConversation, error: convError } = await supabase
        .from("conversations")
        .insert({
          user_numero: userNumero,
          user_type: userType,
          theme: theme || "G√©n√©ral",
          title: message.substring(0, 50) + (message.length > 50 ? "..." : "")
        })
        .select("id")
        .single()

      if (convError) {
        console.error("Erreur cr√©ation conversation:", convError)
        return NextResponse.json(
          { error: "Erreur lors de la cr√©ation de la conversation" },
          { status: 500 }
        )
      }

      currentConversationId = newConversation.id
    }

    // 2. Sauvegarder le message utilisateur
    const { error: userMsgError } = await supabase
      .from("messages")
      .insert({
        conversation_id: currentConversationId,
        role: "user",
        content: message
      })

    if (userMsgError) {
      console.error("Erreur sauvegarde message utilisateur:", userMsgError)
      return NextResponse.json(
        { error: "Erreur lors de la sauvegarde du message" },
        { status: 500 }
      )
    }

    // 3. R√©cup√©rer l'historique de la conversation pour le contexte
    const { data: conversationHistory, error: historyError } = await supabase
      .from("messages")
      .select("role, content, created_at")
      .eq("conversation_id", currentConversationId)
      .order("created_at", { ascending: true })
      .limit(10) // Limiter √† 10 derniers messages pour √©viter de surcharger

    if (historyError) {
      console.error("Erreur r√©cup√©ration historique:", historyError)
    }

    // 4. R√©cup√©rer les informations utilisateur pour le contexte
    const { data: userData, error: userError } = await supabase
      .from("info")
      .select("*")
      .eq("numero", userNumero)
      .single()

    if (userError) {
      console.error("Erreur r√©cup√©ration utilisateur:", userError)
    }

    // 5. Pr√©parer le contexte pour le LLM
    const contextMessages = conversationHistory?.map(msg => ({
      role: msg.role,
      content: msg.content
    })) || []

    // Ajouter le contexte utilisateur si disponible
    let systemContext = `Tu es un assistant pour ${userType === 'accompagne' ? 'une personne accompagn√©e' : 'un accompagnant'} dans le domaine social.`
    
    if (userData) {
      systemContext += ` Informations utilisateur: ${userType === 'accompagne' ? 'Accompagn√©' : 'Accompagnant'}`
      if (userData.ville) systemContext += `, vit √† ${userData.ville}`
      if (userData.langue) systemContext += `, langue pr√©f√©r√©e: ${userData.langue}`
      if (userData["Niveau de francais"]) systemContext += `, niveau fran√ßais: ${userData["Niveau de francais"]}`
    }

    if (theme) {
      systemContext += ` La conversation concerne le th√®me: ${theme}.`
    }

    // 6. Appeler votre API LLM sur Render
    const llmResponse = await callRenderLLM({
      systemContext,
      messages: contextMessages,
      userMessage: message
    })

    if (!llmResponse.success) {
      return NextResponse.json(
        { error: "Erreur lors de la communication avec le LLM" },
        { status: 500 }
      )
    }

    // 7. Sauvegarder la r√©ponse de l'assistant
    const { error: assistantMsgError } = await supabase
      .from("messages")
      .insert({
        conversation_id: currentConversationId,
        role: "assistant",
        content: llmResponse.content
      })

    if (assistantMsgError) {
      console.error("Erreur sauvegarde r√©ponse assistant:", assistantMsgError)
    }

    // 8. Mettre √† jour la conversation (updated_at)
    await supabase
      .from("conversations")
      .update({ updated_at: new Date().toISOString() })
      .eq("id", currentConversationId)

    return NextResponse.json({
      message: llmResponse.content,
      conversationId: currentConversationId,
      success: true
    })

  } catch (error) {
    console.error("Erreur API chat:", error)
    return NextResponse.json(
      { error: "Erreur interne du serveur" },
      { status: 500 }
    )
  }
}

// Fonction pour appeler votre API LLM sur Render
async function callRenderLLM({ systemContext, messages, userMessage }: {
  systemContext: string
  messages: Array<{ role: string; content: string }>
  userMessage: string
}) {
  let context: string | undefined;
  try {
    const lastUserMessage = userMessage.trim();
    context = detectContext(lastUserMessage);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 90000);

    const response = await fetch(`${EXTERNAL_API_URL}/api/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: lastUserMessage,
        context: context || undefined
      }),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`Erreur API: ${response.status}`);
    }

    const data = await response.json();
    let content = data.reply || data.response || data.message;

    if (isResponseIncomplete(content)) {
      content = formatResponse(generateFallbackResponse(lastUserMessage, context || ''));
    } else {
      content = formatResponse(content);
    }

    return { success: true, content };

  } catch (error) {
    console.error("Erreur lors de l'appel au LLM:", error);
    let fallbackContent = generateFallbackResponse(userMessage, context || '');
    if ((error as Error).name === 'AbortError') {
      fallbackContent += "\n\n‚ö†Ô∏è *Timeout de l'API - r√©ponse de base fournie.*";
    }
    return { success: true, content: formatResponse(fallbackContent) };
  }
}

// Fonctions auxiliaires comme dans la doc
function detectContext(message: string): string | undefined {
  const lowerMessage = message.toLowerCase();
  const contexts = [
    { keywords: ['r√©fugi√©', 'demandeur asile', 'protection subsidiaire', 'apatride'], context: 'Personne ayant obtenu le statut de r√©fugi√© ou protection internationale' },
    { keywords: ['√©tudiant', 'universit√©', 'campus france', 'visa √©tudiant'], context: '√âtudiant international en France' },
    { keywords: ['travailleur', 'salari√©', 'carte de s√©jour salari√©', 'contrat de travail'], context: 'Travailleur √©tranger en France' },
    { keywords: ['conjoint fran√ßais', 'mariage', 'regroupement familial', 'visa famille'], context: 'Personne venue en France pour raisons familiales' },
    { keywords: ['premi√®re fois', 'nouvel arrivant', 'viens d\'arriver', 'r√©cemment arriv√©'], context: 'Nouvel arrivant en France' }
  ];
  for (const { keywords, context } of contexts) {
    if (keywords.some(keyword => lowerMessage.includes(keyword))) {
      return context;
    }
  }
  return 'Personne r√©sidant en France';
}

function isResponseIncomplete(response: string): boolean {
  console.error('R√©ponse brute de Render:', response); // Log pour d√©bogage
  const indicators = [
    response.length < 100,
    response.endsWith('...'),
    response.includes('reponse incomplete'),
    response.split('\n').length > 5 && !response.includes('üìö'),
    response.includes('pr√©sente dans de ') && response.endsWith('de ')
  ];
  
  if (response.includes('üè•') || response.includes('##') || response.includes('‚ö†Ô∏è')) {
    return false;
  }
  
  return indicators.some(condition => condition);
}

function formatResponse(response: string): string {
  let formatted = response;

  // Si d√©j√† en Markdown, retourner tel quel
  if (formatted.includes('# ') || formatted.includes('## ') || formatted.includes('### ')) {
    return formatted.trim();
  }

  // √âtape 1: Formatage des Sections Principales avec √âmojis (Niveau 1)
  formatted = formatted.replace(/([üè•üñ•Ô∏èüì±üíª])\s*([^:\n]+)\s*:\s*([^\n]*)/g, '\n\n# $1 $2\n\n$3\n\n');

  // √âtape 2: Formatage des Sous-Sections avec √âmojis (Niveau 2)
  formatted = formatted.replace(/([üìãüìù‚ö†Ô∏èüÜòüí°üìö‚è±Ô∏è])\s*([^:\n]+)\s*:/g, '\n\n## $1 $2\n\n');

  // √âtape 3: Formatage des √âtapes Num√©rot√©es (Version en Gras - Niveau 3)
  formatted = formatted.replace(/(\d+)\.\s*\*\*([^*]+)\*\*\s*:/g, '\n\n### $1. $2\n\n');

  // √âtape 4: Formatage des √âtapes Num√©rot√©es (Version Simple - Niveau 3)
  formatted = formatted.replace(/(\d+)\.\s*([^:\n]+):/g, '\n\n### $1. $2\n\n');

  // √âtape 5: Formatage des Listes √† Puces avec Sous-Titres
  formatted = formatted.replace(/^[\s]*-\s*([^:\n]+):\s*([^\n]*)/gm, '- **$1**: $2');

  // √âtape 6: Formatage des Listes √† Puces Simples
  formatted = formatted.replace(/^[\s]*-\s*/gm, '- ');

  // √âtape 7: Correction des Liens Markdown
  formatted = formatted.replace(/\[([^\]]+)\]\s*\(\s*([^)]+)\s*\)/g, '[$1]($2)');

  // √âtape 8: Correction des URLs Nues
  formatted = formatted.replace(/https:\s*\/\/([^\s]+)/g, 'https://$1');

  // √âtape 9: Formatage des Citations en Gras
  formatted = formatted.replace(/>\s*\*\*([^*]+)\*\*\s*:/g, '\n\n> **$1**:\n\n');

  // √âtape 10: Formatage des Alertes (‚ö†Ô∏è)
  formatted = formatted.replace(/‚ö†Ô∏è\s*([^:\n]+):/g, '\n\n> ‚ö†Ô∏è **Attention**: $1\n\n');

  // √âtape 11: Espacement des Paragraphes
  formatted = formatted.replace(/([.!?])\s*\n\s*([A-Z√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û])/g, '$1\n\n$2');

  // √âtape 12: Formatage de la Section Sources
  formatted = formatted.replace(/## üìö\s*Sources consult√©es/g, '\n\n---\n\n## üìö Sources consult√©es');

  // √âtape 13: Nettoyage des Sauts de Ligne Excessifs
  formatted = formatted.replace(/\n{4,}/g, '\n\n\n');
  formatted = formatted.replace(/^\n+|\n+$/g, '');

  // √âtape 14: Espacement Final des Titres
  formatted = formatted.replace(/\n(#{1,6}\s)/g, '\n\n$1');
  formatted = formatted.replace(/(#{1,6}\s[^\n]+)\n([^\n#])/g, '$1\n\n$2');

  return formatted.trim();
}

function generateFallbackResponse(message: string, context: string): string {
  const lowerMessage = message.toLowerCase();
  if (lowerMessage.includes('demande d\'asile') && (lowerMessage.includes('puma') || lowerMessage.includes('protection universelle'))) {
    return `üè• **PUMa et demande d'asile en cours**\n\nüìã **D√©lai de carence obligatoire :**\n- Depuis janvier 2020, il y a un **d√©lai de carence de 3 mois** pour les demandeurs d'asile majeurs\n- Vous devez attendre 3 mois apr√®s l'enregistrement de votre demande d'asile\n\n‚ö†Ô∏è **Exception importante :**\n- Les **mineurs** demandeurs d'asile ont acc√®s imm√©diat √† la PUMa\n- Pas de d√©lai d'attente pour les enfants\n\nüÜò **Pendant les 3 premiers mois :**\n- **Soins urgents** pris en charge aux urgences hospitali√®res\n- **PASS** (Permanences d'Acc√®s aux Soins de Sant√©) dans les h√¥pitaux\n- Centres de sant√© communautaires\n- Consultations gratuites dans certaines associations\n\nüìû **Contacts utiles :**\n- CPAM : 36 46\n- 115 (urgence sociale)\n- M√©decins du Monde, M√©decins Sans Fronti√®res\n\n‚è∞ **Apr√®s 3 mois :** Vous pourrez b√©n√©ficier de la PUMa compl√®te.`;
  }
  if (lowerMessage.includes('r√©fugi√©') && lowerMessage.includes('assurance maladie')) {
    return `üè• **Assurance maladie et statut de r√©fugi√©**\n\nF√©licitations pour l'obtention de votre statut de r√©fugi√© ! Concernant l'assurance maladie :\n\nüìã **Votre situation actuelle :**\n- Si vous b√©n√©ficiez actuellement de l'AME (Aide M√©dicale d'√âtat), vous devez effectuer une nouvelle demande\n- Votre couverture ne se poursuit PAS automatiquement\n\nüîÑ **D√©marches √† effectuer :**\n1. **Demande d'affiliation √† l'Assurance Maladie** aupr√®s de votre CPAM\n2. **Documents √† fournir :**\n   - R√©c√©piss√© ou carte de s√©jour "r√©fugi√©"\n   - Justificatif de domicile\n   - Pi√®ce d'identit√©\n\n‚è∞ **D√©lais :**\n- Faites la demande **d√®s que possible** pour √©viter toute interruption\n- La CPAM a 2 mois pour traiter votre dossier\n\nüéØ **Avantages du nouveau statut :**\n- Acc√®s aux m√™mes droits qu'un assur√© fran√ßais\n- Possibilit√© d'obtenir une carte Vitale\n- Prise en charge √† 100% selon votre situation\n\nüìû **Contact :** 36 46 (service gratuit + prix d'un appel)\n\n‚ö†Ô∏è **Important :** N'attendez pas la fin de vos droits AME pour faire la demande !`;
  }
  return `üëã Bonjour ! Je suis l'assistant pour les nouveaux arrivants en France.\n\nJe peux vous aider sur :\nüè• Sant√© (s√©curit√© sociale, m√©decins)\nüè† Logement (recherche, aides)\nüìã Administratif (cartes, permis)\nüíº Emploi et formation\nüöó Transport\nüí∞ Finances\n\n${context ? `\nüéØ **Votre profil :** ${context}` : ''}\n\nN'h√©sitez pas √† me poser une question plus pr√©cise !`;
} 